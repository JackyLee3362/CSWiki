## 2.4死锁 Deadlocked
### 死锁的概念
- 死锁的定义
- 死锁产生的原因
    - 系统资源的竞争
    - 进程推进顺序非法
    - 死锁产生的必要条件
        - 互斥条件
        - 不剥夺条件
        - 请求并保持条件
        - 循环等待条件
- ~与「饥饿」的区别
    - 进入「饥饿」状态的进程可以只有一个，而因循环等待条件而进入死锁状态的进程却必须大于等于两个
    - 处于「饥饿」状态的进程可以是一个就绪进程，如静态优先权调度算法时的低优先权进程，而处于死锁状态的进程必定是阻塞进程
### 死锁的处理策略
- 死锁约访
- 避免死锁
- 死锁的检测及解除
### 死锁预防
- 破坏互斥条件
- 破坏不剥夺条件
- 破坏请求并保持条件―预先静态分配方法，一次申请所有资源
- 破坏循环等待条件―顺序资源分配法
### 死锁避免
- 系统安全状态：并非所有的不安全状态都是死锁状态
- 银行家算法
    - 数据结构描述
        - 最大需求矩阵Max
        - 分配矩阵Alocation
        - 需求矩阵Need
        - Need = Max - Allocation
    - 银行家算法描述
- 安全性算法
    - 工作向量Work
    - 安全性算法举例（王道书126）
- 银行家算法举例
### 死锁检测和解除
- 资源分配图
- 死锁定理
- 死锁解除
    - 资源剥夺法
    - 撤销进程法
    - 进程回退法
### 习题
- 4 系统产生死锁的可能原因是
A 独占资源分配不当
B 系统资源不足
C 进程运行太快
D CPU内核太多→A
- 22
- 26【2016】
- 27
- 28【2011】
- 29【2012】
- 30【2014】
- 31【2016】
- 32【2015】若系统S1采用死锁避免方法，S2采用死锁检测方法。下列叙述中，正确的是
① S1会限制用户申请资源的顺序
② S1需要进程运行所需的资源总量信息，而S2不需要
③ S1不会给可能导致死锁的进程分配资源，而S2会→②③，①是死锁预防
- 33【2018】假设系统中有4个同类资源，进程P1、P2和P3需要的资源数分别为4、3和1，P1、P2和P3已申请到的资源数分别为2，1和0，则执行安全性检测算法的结果是
A 不存在安全序列，系统处于不安全状态
B 存在多个安全序列，系统处于安全状态
C 存在唯一安全序列P3、P1和P2，系统处于安全状态
D 存在唯一安全序列P3、P2和P1，系统处于安全状态→A
- 34【2019】
- 35【2020】