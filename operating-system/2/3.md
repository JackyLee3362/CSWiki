## 2.3进程同步
### 进程同步的基本概念
- 临界区 critical section
    - 概念：访问临界资源的代码称为临界区
    - 临界资源―一次仅允许一个进程使用的资源称为临界资源
        - 临界资源的访问过程 ↓ 
            - 进入区
            - 临界区
            - 退出区
            - 剩余区
```cpp
do{
entry section; // 进入区
critical section; // 临界区
exit section; // 退出区
remainder section; // 剩余区
} while(true)
```
- 同步―直接制约关系
- 互斥―间接制约关系
- 为了防止两个进程同时进入临界区，同步机制应该遵循以下原则
    - 空闲让进
    - 忙则等待
    - 有限等待―对请求访问的进程，应保证能在有限时间内进入临界区
    - 让权等待―当进程不能进入临界区时，应立即释放处理器，防止进程忙等待
### 实现临界区互斥的基本方法
- 软件实现方法
    - 单标志法
    - 双标志法先检查
    - 双标志法后检查
    - Peterson's Algorithm
- 硬件实现方法（低级方法，元方法）
    - 中断屏蔽方法（屏蔽中断，关中断）
    - 硬件指令方法
        - TestAndSet指令
        - Swap指令
        - 优点： 适用于任意数目的进程，而不管是单处理机还是多处理机；简单容易检验正确性
        - 缺点：进程等待进入临界区时要耗费处理机时间，不能实现让权等待
- 信号量
    - 概念：只能被两个标准的原语 wait(S) 和 signal(S) 访问，也可以记作 P操作和V操作
    - 整型信号量
        - 一个用于表示资源数目的整型量S
```cpp
wait(S){
while(S <= 0);
S--;0
}

signal(S){
S++;
}
```
- 记录型信号量
```cpp
typedef struct{
int value;
struct process *L;
}semaphore;
```
- 相应的wait(S) 和 signal(S)的操作如下
- wait(S)
```cpp
void wait(semaphore S){ // 相当于申请资源
S.value--;
if(S.value < 0){
add this process to S.L;
block(S.L);
}
}
```
- signal(S)
```cpp
void signal(semaphore S){ // 相当于释放资源
S.value++;
if(S.value <= 0){
remove a process P from S.L;
wakeup(P);
}
}
```
- 利用信号量实现同步
```cpp
semaphore S = 0; // 初始化信号量
P1(){
x;		// x语句
V(S);   // 告诉进程2，语句x已经完成
}
P2(){
P(S);   // 检查语句x是否运行完成
y;		// 检查无误，运行y语句
}
```
- 利用信号量实现进程互斥
```cpp
...
P(S);
critical section
V(S); 
...
```
- 利用信号量实现前驱关系
### 管程 monitor
- 概念
    - 统一管理共享资源的所有访问，实现进程互斥，这个代表共享资源的数据结构，以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序，称为管程
- 组成
    - 管程的名称
    - 局部于管程内部的共享结构数据说明
    - 对该数据结构进行操作的一组过程（或函数）
    - 对局部于管程内部的共享数据设置初始值的语句
- 条件变量 condition
    - x.wait
    - x.signal
### 经典同步问题  
    - 生产者消费者问题：有点像管道通信中的read 和 write 
    - 读者写者问题
    - 哲学者进餐问题
    - 吸烟者问题
### 习题  
    - 4【2010】设与某资源关联的信号量的初值为3，当前值为1。若M表示该资源的可用个数，N表示等待该资源的进程数，则M，N分别是→1，0
    - 10 以下什么属于临界资源？ 
A. 磁盘存储介质 
B. 公用队列 
C. 私用数据 
D. 可重入的程序代码→B
    - 20 可以被多个进程在任意时刻共享的代码必须是？ 
A. 顺序代码 
B. 机器语言代码 
C. 不允许任何修改的代码 
D. 无转移指令的代码→C
    - 27 若一个系统中共有5个并发进程涉及某个相同的变量A，则变量A的相关临界区是由？个临界区构成的→5
    - 37【2010】
    - 38【2016】30![](local://D:/OneDrive/Documents/2021/RemNote/publish-cs/files/Jm07ackviYB49nwb_wVU3MLo9TNGZ2jPm4qair9mXeUvpsGL7XuqQA5wKDstJobudm7Jr7mfBqo1knqEKrbDrt1X4VKP2MbdcKHVSFc9_VC8jasl0ps77ISidbE4O5kS.png)→C
    - 39【2011】
    - 40【2016】使用TSL（Test and Set Lock）指令实现进程互斥的伪代码如下所示```c
do{
...
while(TSL(&lock));
critical section;
lock = FALSE;
...
}while(TRUE);
```下列与该实现机制相关的叙述中，正确的是
A 退出临界区的进程负责唤醒就绪态进程
B 等待进入临界区的进程不会主动放弃CPU
C 上述伪代码满足「让权等待」的同步准则
D while(TSL(&lock))语句应在关中断状态下执行→B
    - 43 在9个生产者、6个消费者共享容量为8的缓冲器的生产者-消费者问题中，互斥使用缓冲器的信号量的初始值是？→1
    - 46【2018】
    - 47【2018】若x是管程内的条件变量，则当进程执行x.wait()时所做的工作是？ 
A. 实现对变量x的互斥访问 
B. 唤醒一个在x上阻塞的进程 
C. 根据x的值判断该进程是否进入阻塞态 
D. 阻塞该进程，并将之插入x的阻塞队列中→D
    - 48【2018】
    - 49【2020】下列准则中，实现临界区互斥机制必须遵循的是
① 两个进程不能同时进入临界区
② 允许进程访问空闲的临界资源
③ 进程等待进入临界区的时间是有限的
④ 不能进入临界区的执行态进程立即放弃CPU
答案→①②③，①满足「忙则等待」原则；②满足「空闲让近」原则；③满足「有限等待」原则；④是「让权等待」，不一定非得实现，如皮特森算法；
    - 综合题3【2009】
    - 综合题8【2013】
    - 综合题12【2011】
    - 综合题20【2014】
    - 综合题22【2015】
    - 综合题23【2017】
    - 综合题24【2019】
    - 综合题25【2020】